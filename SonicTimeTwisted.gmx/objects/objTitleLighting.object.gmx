<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprTitleLighting</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>4</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Setup Shader
timetravel_shader_init(sprite_width, sprite_height);
time = 0;
image_speed = .25;
image_xscale=1;
image_yscale=1;
spr=sprite_index;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clean up
if (surface_exists(tt_surface)) surface_free(tt_surface);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// increase the shift amount; this will cycle the colours
shift += 0.01;
time++;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clean up
if (surface_exists(tt_surface)) surface_free(tt_surface);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check Surface Exists
if (!surface_exists(tt_surface) &amp;&amp; view_yview &lt; room_height - view_hview - 64)
{
    tt_surface = surface_create(426, 240);
}
if (view_yview &gt;= room_height - view_hview - 64)
{
    instance_destroy();
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the lightning to the surface.
// set the drawing target to the surface
var temp_Detail = 30;
var temp_Centre = 213;
var temp_Offset = 25;
var temp_Sign   = 1;
var temp_Height = 0;
var temp_Wave_1 = 0; // standard wave
var temp_Wave_2 = 0; // spikes
var temp_Wave_3 = 0; // larger wave
    if (view_yview &lt; room_height - view_hview - 64)
    {
surface_set_target(tt_surface);
    draw_clear_alpha(c_black, 0);
    draw_primitive_begin(pr_trianglefan); // pr_trianglefan // pr_linestrip
    draw_vertex_colour(213, 120, c_white, 1);
        for (var j = 0; j &lt; 2; j++)
        {
            for (var i = 0; i &lt; temp_Detail; i++)
            {
                if (!j)
                {
                    temp_Wave_1 = sin(degtorad(time / 8 + (i) + (view_yview / 80) * temp_Sign) * 16 + (view_yview / 40) * temp_Sign) * (10 / (max(1, view_yview / 240) * temp_Sign));
                }
                else
                {
                    temp_Wave_1 = cos(degtorad(time / 8 - (i) - (view_yview / 80) * temp_Sign) * 16 - (view_yview / 40) * temp_Sign) * (10 / (max(1, view_yview / 240) * temp_Sign));
                }
                // temp_Wave_1 = sin(degtorad(time / 8 + i + (view_yview / 60) * temp_Sign) * 16) * 10;
                draw_vertex_colour(temp_Centre + ((temp_Offset / max(1, view_yview / 240)) * temp_Sign) + (temp_Wave_1 * temp_Sign) + (temp_Wave_2 * temp_Sign), temp_Height, c_white, 1);
                temp_Height += (240 / temp_Detail) * temp_Sign;
            }
            if (!j)
            {
                temp_Wave_1 = sin(degtorad(time / 8 + i + (view_yview / 80) * temp_Sign) * 16 + (view_yview / 40) * temp_Sign) * (10 / (max(1, view_yview / 240) * temp_Sign));
            }
            else
            {
                temp_Wave_1 = cos(degtorad(time / 8 - (i) - (view_yview / 80) * temp_Sign) * 16 - (view_yview / 40) * temp_Sign) * (10 / (max(1, view_yview / 240) * temp_Sign));
            }
            draw_vertex_colour(temp_Centre + ((temp_Offset / max(1, view_yview / 240)) * temp_Sign) + (temp_Wave_1 * temp_Sign) + (temp_Wave_2 * temp_Sign) + (temp_Wave_3 * temp_Sign), temp_Height, c_white, 1);
            temp_Sign *= -1;
        }
        temp_Sign = 1;
        temp_Height = 0;
        temp_Wave_1 = sin(degtorad(time / 8 + (view_yview / 80) * temp_Sign) * 16 + (view_yview / 40) * temp_Sign) * (10 / (max(1, view_yview / 240) * temp_Sign));
        draw_vertex_colour(temp_Centre + ((temp_Offset / max(1, view_yview / 240)) * temp_Sign) + (temp_Wave_1 * temp_Sign) + (temp_Wave_2 * temp_Sign) + (temp_Wave_3 * temp_Sign), temp_Height, c_white, 1);
    draw_primitive_end();
    /*temp_Sign = 1;
    temp_Height = 0;
    temp_Wave_1 = 0;
    for (var j = 0; j &lt; 2; j++)
    {
        for (var i = 0; i &lt; temp_Detail; i++)
        {
            temp_Wave_1 = sin(degtorad(time / 8 + i) * 16) * 10;
            draw_point_colour(clamp(temp_Centre + (temp_Offset * temp_Sign) + (temp_Wave_1 * temp_Sign), 0, 425), clamp(temp_Height, 0, 239), c_black);
            temp_Height += (240 / temp_Detail) * temp_Sign;
        }
        temp_Wave_1 = sin(degtorad(time / 8 + i) * 16) * 10;
        draw_point_colour(clamp(temp_Centre + (temp_Offset * temp_Sign) + (temp_Wave_1 * temp_Sign), 0, 425), clamp(temp_Height, 0, 239), c_black);
        temp_Sign = -1;
    }*/
surface_reset_target();
    }
// draw the sprite mirrored on the y axis to create the zipper shape
//draw_sprite_ext(spr, floor(image_index), xoffset, 0, 1, 1, 0, c_white, 1);
//draw_sprite_ext(spr, floor(image_index), 0, 1, 1, 1, 0, c_white, 1); // ORIGINAL IMAGE
// reset the drawing target to the screen
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the surface.
// draw a dummy background for the effect to cover
//draw_background_ext(zonebkg, 0, 0, 2, 2, 0, c_white, 1);
// turn on the time travel effect shader
if (view_yview &lt; room_height - view_hview - 64)
{
    timetravel_shader_draw(sprite_width, sprite_height, 0, view_yview);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
